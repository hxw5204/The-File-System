<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<!-- saved from url=(0062)http://www.cse.psu.edu/~trj1/cmpsc473-19f/cmpsc473-19f-p4.html -->
<html class="gr__cse_psu_edu"><head><meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
    <title>CMPSC 473 - Project #4 - Extended Attributes</title>
  
  <meta name="keywords" content="CMPSC 473">
  <meta name="keywords" content="Operating Systems">
  <meta name="description" content="CMPSC 473 Home Page">
  <link href="./CMPSC 473 - Project #4 - Extended Attributes_files/style.css" rel="stylesheet" type="text/css">
  <link rel="SHORTCUT ICON" href="http://www.cse.psu.edu/~trj1/cmpsc473-19f/psuicon.png">
  </head>


  <body data-gr-c-s-loaded="true">
    <h1>CMPSC 473 - Project #4 - Extended Attributes</h1>


<p><b>Due Date</b>: December 13, 2019 (11:59pm).  60 points</p>

<p>Single person project. <b>Do your own work!</b></p>

<p>In this project, you will extend a provided RAM disk file system
with extended attributes that are used to store ad hoc metadata with
files.  While this code is not based directly on any OS
implementation, it does share the common concepts from a UNIX file
system.

</p><h2>The File System</h2>

<p>The provided RAM disk file system stores its "disk" configuration
in memory when you run the project.  That is, the layout of the disk
is exactly the layout in memory.  You will extend this file system
with extended attribute that can be added to any file.  Fortunately,
this extension is largely orthogonal to the provided file system, but
there are some lessons to be learned from studying and understanding
the file system code provided that you can apply.</p>

<p>The file system is defined by its structure shown below.</p>

<img align="middle" src="./CMPSC 473 - Project #4 - Extended Attributes_files/fs.png">

<p>The file system consists of a series of <b>blocks</b>, which
although in memory in your project correspond to the layout of the
file system on disk.  The main structures used to implement the
different types of file system metadata, including blocks are defined
in the file <b>cmpsc473-filesys.h</b> in the project code.  <b>Do not
modify this file.</b> </p>

<p>Each block is prefaced by its block metadata specified in
a <b>dblock_t</b> structure.  The block metadata determines the type
of block (<b>free</b>, which also indicates whether the type is to be
determined), the next block in a list of free blocks (<b>next</b>),
and metadata about the block in a union data structure (<b>st</b>),
which may either reference a bitmap (for a dentry block) or the end of
the block data (e.g., for data blocks).
  
</p><p>The last field (<b>data[0]</b>) is a reference to the block's data.
Note that although this field is declared as an array of size 0, it is
actually just a reference to a field whose size is determined at
runtime.  In the case of blocks, the data in the block is determine by
the block type (see BLOCK definitions in cmpsc473-filesys.h).  While
this may be uncommon in user-space programs, it is common in the Linux
kernel - to avoid wasting memory for objects whose size is only known
at runtime.</p>

<p>Below, we detail the file system structure shown in the figure above.</p>

<ul>

<li><p>Block 0 is the <b>file system block</b> or <b>superblock</b>, which
defines the overall structure of the file system using a structure of
type <b>dfilesys_t</b>.  This block states the number of blocks in the
file system (<b>bsize</b> field), the offset in blocks to the next
free block (<b>firstfree</b> field), and the offset to the root
directory block of the file system (<b>root</b> field).</p>

</li><li><p>Block 1 stores the <b>root directory block</b> of
type <b>ddir_t</b>, which is the only directory in our filesystem.
Each on-disk directory stores a set of references to directory entries
(dentries) using a hash table.  The on-disk directory stores the
number of buckets in its hashtable (<b>buckets</b>), the free dentry
block (see below) for storing the next directory entry
(<b>freeblk</b>), and the first free dentry slot index in that dentry
block (<b>free</b>).  The last field (<b>data[0]</b> indicates the
start of the hash table (the first bucket) for the directory
block.</p>

</li><li><p>Block 2 is a <b>directory entry (dentry) block</b>, which stores a
series of directory entries (dentries) of type <b>ddentry_t</b>.  The
dentries store information about each entry in a directory (i.e., file
or subdirectory).  In this project, we only have files, so there are
only dentries for files.  Each dentry records its file's <b>file
control block</b> (<b>block</b>), which is the first block for a file,
the next dentry in the directory's hash table (<b>next</b>), and the
file name (<b>name[0]</b>) and name length (<b>name_size</b>).</p>

<p>Thus, directory entry hash table starts in the directory block - by
finding the bucket a file name corresponds to - and then traverses
directory entries in dentry blocks using the next pointer to find
the <b>next_dentry</b> block and dentry <b>next_slot</b> using
the <b>ddh_t</b> structures.  That is probably the most complicated
thing about this file system.</p>

</li><li><p>Block 3 is a <b>file control block</b>, which stores the metadata
for a particular file using type <b>fcb_t</b>.  The file control block
stores the file permissions available to your one process to this file
(<b>flags</b>), the size of the file in bytes (<b>size</b>), the file
data blocks (<b>blocks</b>, up to 10 in this project), and the first
file attribute block (<b>attr_block</b>, see Extended Attributes
below).  There will be several file control blocks - one for each file
created.</p>

</li><li><p>Block 4 is a <b>data block</b>, which is used to store file data.
The <b>dblock_t</b> structure at the start of every block is used to
manage the file data, which is written starting in the <b>data[0]</b>
field, and whose current length is recorded by the <b>data_end</b>
field (in the union).

</p></li></ul>

<h2>Extended Attributes</h2>

<p>Your task will be to extend the provided file system with extended
attributes for files.  This section provides background on extended
attributes and your specific project tasks.</p>

<h3>Background</h3>

<p>Many file systems now support extensible storage of file metadata
in the form of <b>extended attributes</b>.  Programs and the kernel
may associate attribute-value pairs with a file for any purpose they
desire by storing these pairs with the file as extended
attributes.</p>

<p>The way the project uses extended attributes largely follows the
extended attribute definitions shown in the manpages
for <a href="http://linux.die.net/man/2/fsetxattr">fsetxattr</a> and
for <a href="http://linux.die.net/man/2/fgetxattr">fgetxattr</a>.  The
full tarball for the project is
available <a href="http://www.cse.psu.edu/~trj1/cmpsc473-19f/p4-xattr.tgz">here</a>.</p>

<p>This project will focus on two separate data blocks, <b>File Xattr
Control Blocks (attribute blocks)</b> and <b>Xattr Data Blocks (value
blocks)</b>.  These are shown in this diagram.</p>

<img align="middle" src="./CMPSC 473 - Project #4 - Extended Attributes_files/attr.png">

<ul>
<li><p>Block 5 shows a file's extended attribute (xattr) control
block.  It is a data block (dblock_t) for one file that contains a
structure describing the xattr information, called the <b>xattr
control block</b> of type <b>xcb_t</b>.  At the end of the xcb_t is a
reference to an array of attribute structures of type <b>dxattr_t</b>.
We will store <b>all the attribute structures</b> in this one block.  The
array of 0 indicates that we do not really know how big these data
structures are, nor how many we will really store, so we just leave it
to be determined at runtime.  This is actually a common practice in
the Linux kernel.

</p></li><li><p>Blocks 6 and 7 are data blocks that store the corresponding
attribute values.  As values can vary in size, they are just written
like a log to the data block.  That is, if we first write an
attribute <b>x</b>'s value <b>10</b>, it is written to the data block
at the beginning.  If we change the value to <b>11</b>, then we write
this value after 10, and update the location in the attribute
structure (value_offset).  As shown, values can span multiple value
blocks.

</p></li><li><p>Using the extended attributes for a file entails allocating and
initializing an xattr control block (on the first attribute to be
set).  The xcb_t structure maintains the number of extended attributes
stored (<b>no_xattrs</b>) (one dxattr_t entry in this block for each),
the size of the dxattrs for this block (<b>size</b>), and the
references to the value blocks (<b>value_blocks</b>) used for the
correpsonding attribute values.</p>

<p>For subsequent attributes, create a new dxattr_t structure (after
the current ones) and add the value at the end of the xattr data
block.  Make sure that the dxattr_t for the attribute <b>name</b>
stores the offset of the <b>value</b> in the value blocks (in the
field <b>value_offset</b>).  We can remove a value by setting it to a
blank value.  We never remove an attribute once created.  Consider
leveraging <b>diskWrite</b> to write the value because the value may
span multiple blocks.

</p><p>In the course of setting attributes, you will have to implement the
processing of the flags <b>XATTR_CREATE</b> and <b>XATTR_REPLACE</b>,
where the former requires that no xattr of that name has been created
previous (to prevent collisions) and where the latter requires that
the xattr already be defined.  See more below.

</p></li><li><p>Getting an attribute value entails, retrieving the file xattr
control block, reading the xcb_t structure to find the dxattr_t
structure with the <b>name</b> string, getting the location of the
value string and its size from that dxattr_t structure, and retrieving
the corresponding value from the appropriate block.  I create the
buffer for you and print the value.  Consider using <b>diskRead</b> as
values may span multiple blocks.

</p></li></ul>

<h3>Project Tasks</h3>

<p>In particular, you are going to be required to implement four
functions to enable use of extended attributes.</p>

<ul>

<li><p><b>int fileSetAttr( unsigned int fd, char *name, char *value,
unsigned int name_size, unsigned int value_size, unsigned int flags
)</b>: This function sets an attribute of <b>name</b> (length
of <b>name_size</b>) of a file specified by the descriptor <b>fd</b>
to <b>value</b> (length of <b>value_size</b>) given the <b>flags</b>
value.  The flags values can be <b>XATTR_CREATE</b>, which requires
that the attribute not be assigned to the file previously,
and <b>XATTR_REPLACE</b>, which requires that the attribute already
has been assigned to the file.  Your code needs to return an error if
the conditions are not consistent with the flags.  Otherwise, your
code should set the attribute's value (more detail below).</p>

<p>A key function of your code will be to retrieve a block to store
extended attributes for the file and assign it to the file
(file-&gt;attr_block).  Once assigned, this block should also be made
available to the in-memory file (file_t) and the file control block
(fcb_t).  Then, the attr_block index can then be retrieved from either
the file or the disk, but you should look for this value on the file
structure before reading from the fcb (the disk).  The same should be
done for fileGetAttr below.</p>

</li><li><p><b>int fileGetAttr( unsigned int fd, char *name, char *value,
unsigned int name_size, unsigned int size )</b>: This function
retrieves the value of a file's attribute <b>name</b> (length
of <b>name_size</b>).  The function also takes a buffer for the value,
called <b>value</b>, that is allocated to accept string of up
to <b>size</b> bytes.  Your code should return the number of bytes
read into the <b>value</b> buffer.  If no attribute of <b>name</b> is
assigned, then nothing (0 bytes) is returned.</p>

</li><li><p><b>int diskSetAttr( unsigned int attr_block, char *name, char
*value, unsigned int name_size, unsigned int value_size )</b>: Writes
the <b>value</b> to a disk data block associating it with
the <b>name</b> attribute.  As described in detail
below, <b>attr_block</b> is the data block for attribute structures
(<b>dxattr_t</b>), so <b>diskSetAttr</b> must create a structure
for <b>name</b> if not already there. The attribute values are stored
in separate data blocks referenced from the attribute structure.  

</p></li><li><p><b>int diskGetAttr( unsigned int attr_block, char *name, char
*value, unsigned int name_size, unsigned int size, unsigned int
existsp )</b>: Reads the attribute <b>name</b> from
the <b>attr_block</b> to retrieve the attribute data structure.  This
structure contains an offset in the value data blocks to enable
retrieval of the value which is written to the <b>value</b> buffer up
to length size.  If the <b>existsp</b> flag is set, then this function
only returns whether the attribute of <b>name</b> exists (regardless
of whether it has a non-null value).</p>

</li><li>Note that reading and writing attributes bears some resemblance to
reading and writing generate disk data (although the structures for
attributes are different (see below).  However, you should use
file/diskRead and file/diskWrite for guidance.
</li></ul>


<p>In the assignment, an output file (<b>p4-ooutput</b> in the
tarball) shows the sequence of commands and responses for your file
system.  You will run 5 commands to generate this
output: <b>./cmpsc473-p4 your_fs cmdi &gt;&gt;&amp; p4-output</b>
where <b>cmdi</b> is the ith command for (e.g., cmd1 for the first).
This program is deterministic, so your output should match mine (bug
disclaimer here).</p>

<p>NOTE: The functionality for cmd1 and cmd2 are part of the provided
file system.  

</p><p>Grading: </p>

<ul>
<li>Submission builds and executes automatically: 6 points
</li><li>fileSetAttr and diskSetAttr expected behavior: 22 points 
</li><li>fileGetAttr and diskGetAttr expected behavior: 22 points
</li><li>XATTR_CREATE and XATTR_REPLACE error cases handled: 10 points 
</li></ul>

<hr>
    <address><a href="mailto:tjaeger@cse.psu.edu">Trent Jaeger</a></address>
  

</body><span class="gr__tooltip"><span class="gr__tooltip-content"></span><i class="gr__tooltip-logo"></i><span class="gr__triangle"></span></span></html>